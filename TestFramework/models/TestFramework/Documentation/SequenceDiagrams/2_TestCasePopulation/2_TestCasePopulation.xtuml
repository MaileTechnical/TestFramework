-- BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

INSERT INTO EP_PKG
	VALUES ("5480fefe-8866-48c2-8352-6ed990574e9e",
	"00000000-0000-0000-0000-000000000000",
	"b06a8228-7533-46d6-b644-27cf49555288",
	'2_TestCasePopulation',
	'',
	0);
INSERT INTO GD_MD
	VALUES ("f35e97be-7baf-4a0f-a25e-3cd27c5c50b1",
	112,
	"5480fefe-8866-48c2-8352-6ed990574e9e",
	108,
	0,
	0,
	1,
	1,
	1,
	12,
	1,
	0,
	0,
	0,
	0,
	0,
	'4.1.17',
	'TestFramework::Documentation::SequenceDiagrams::2_TestCasePopulation');
INSERT INTO GD_GE
	VALUES ("84d8e56f-14e0-4b35-ba06-dcd2de5c7999",
	"f35e97be-7baf-4a0f-a25e-3cd27c5c50b1",
	"2727c7d1-a77f-417c-8f1b-bd16fc749175",
	107,
	0,
	'TestFramework::Documentation::SequenceDiagrams::2_TestCasePopulation::TestFramework::Components::TestSequencer');
INSERT INTO GD_SHP
	VALUES ("84d8e56f-14e0-4b35-ba06-dcd2de5c7999");
INSERT INTO GD_NCS
	VALUES ("84d8e56f-14e0-4b35-ba06-dcd2de5c7999");
INSERT INTO DIM_ND
	VALUES (277.000000,
	85.000000,
	"84d8e56f-14e0-4b35-ba06-dcd2de5c7999");
INSERT INTO DIM_GE
	VALUES (4248.000000,
	3144.000000,
	"84d8e56f-14e0-4b35-ba06-dcd2de5c7999",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("84d8e56f-14e0-4b35-ba06-dcd2de5c7999",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_CON
	VALUES ("6277ee6b-df66-4678-9077-de62bdaa232a",
	3492.000000,
	3181.000000,
	"84d8e56f-14e0-4b35-ba06-dcd2de5c7999");
INSERT INTO GD_GE
	VALUES ("aacea8d7-daed-48a9-9196-24a562f05ff0",
	"f35e97be-7baf-4a0f-a25e-3cd27c5c50b1",
	"56d9d283-f190-4472-b35e-cf4f8b326f47",
	107,
	0,
	'TestFramework::Documentation::SequenceDiagrams::2_TestCasePopulation::testbench');
INSERT INTO GD_SHP
	VALUES ("aacea8d7-daed-48a9-9196-24a562f05ff0");
INSERT INTO GD_NCS
	VALUES ("aacea8d7-daed-48a9-9196-24a562f05ff0");
INSERT INTO DIM_ND
	VALUES (216.000000,
	85.000000,
	"aacea8d7-daed-48a9-9196-24a562f05ff0");
INSERT INTO DIM_GE
	VALUES (4680.000000,
	3144.000000,
	"aacea8d7-daed-48a9-9196-24a562f05ff0",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_ELE
	VALUES ("aacea8d7-daed-48a9-9196-24a562f05ff0",
	0,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO DIM_CON
	VALUES ("af2af7a1-fc29-47c1-a8ff-20c6276f72d3",
	3900.000000,
	3181.000000,
	"aacea8d7-daed-48a9-9196-24a562f05ff0");
INSERT INTO DIM_DIA
	VALUES ("f35e97be-7baf-4a0f-a25e-3cd27c5c50b1",
	'',
	1.000000,
	0.000000,
	0.000000,
	"00000000-0000-0000-0000-000000000000");
INSERT INTO SQ_P
	VALUES ("2727c7d1-a77f-417c-8f1b-bd16fc749175",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO SQ_COP
	VALUES ("2727c7d1-a77f-417c-8f1b-bd16fc749175",
	"6458b090-4d5d-4bec-a376-1c820254581c",
	'TestFramework::Components::TestSequencer',
	'TestSequencer',
	'',
	1);
INSERT INTO C_C_PROXY
	VALUES ("6458b090-4d5d-4bec-a376-1c820254581c",
	"00000000-0000-0000-0000-000000000000",
	"00000000-0000-0000-0000-000000000000",
	'TestSequencer',
	'Overview:

This is a service to automate the running of a suite of multiple self-checking test cases.

Typically a self-checking test case has three primary components:
1. Establish pre-conditions.
2. Inject stimulus.
3. Verify (observe) post-stimulus conditions.
Often, the injection of stimuli and the observation of post-conditions
are intermixed, as the test case injects a stimulus, verifies the response(s), 
injects additional stimuli, and so on.

While stimulus actions and observation measurements are subject-matter specific, the organization 
of sequencing stimuli and adjudication of success or failure are not. Hence this service.


Summary description:

This subject matter-independent Test Sequencer service asumes the burdens of sequencing, timer 
management, requirements coverage tracking and summary reporting for multi-threaded test cases 
ordered in test buckets within a test suite.

A testbench, with subject matter-specific details of stimuli and observations, can use this 
service to manage its interaction with a system under test.

A test suite is configured to contain one or more of test buckets which are added in order.
Each test bucket ''scripts'' at least one test case; typically several related tests.

When all test buckets have been added to the test suite, the test suite is signalled to execute.
In turn, each bucket is signalled to execute the script that builds its test cases and run them.

A test case consists of one or more sequences of stimuli and following observations.
The instances in the testbench have counterparts in the test service where sequencing is managed.
The script creates stimuli and observation instances which add themselves to the test service.
When the test bucket script is complete its test cases are run in order.
Running a test case involves appropriate invocation of the stimulus interactions with the system 
under test and evaluating the system''s response as measured by observations.


Some details:

Multiple sequences of stimuli may run concurrently in a test case execution.
A stimulus effects some changes in a system under test.
Following observations may evaluate the response of the system to such a stimulus.
Observations may evaluate sequentially in a defined order, or concurrently if so configured.
Observations may be triggered to evaluate on some occurence, or may poll, repeatedly evaluating.
Observations may be limited in duration; failure to succeed within this time constitutes failure.
Time delays can be interspersed between stimuli and observations and between observations.
All observations following a stimulus must complete before the next stimulus is injected
If all observations are found acceptable, the test case is deemed to be successful.
If any observation fails, the test case ceases execution: all sequences discontinue.
A test case may be associated with instances of requirements to support coverage reporting.


Usage:

To use the service, a testbench must derive its test bucket, stimuli and observation classes from 
the supertype classes provided in the sample testbench component and use the operations supplied 
in the supertypes to interface with the service.

In principle, a testbench registers a test suite with the service, supplying a name and optionally 
selecting a timescale which will be default for the testcases it will contain. The testbench adds 
test buckets to the suite and populates each bucket with test cases comprised of stimuli and 
observations. A test bucket contains at least one test case, but commonly a number of cases which 
share some common purpose, such as comprehensive testing of a subgroup of requirements. 

Optionally, a testbench can register instances of requirements with the service. There is provision 
for associating any such requirement with one or more test case instances; the service will provide 
a summary report on requirements coverage at completion of testing.

A test case may choose to specify pre-conditions which should be established before the case is run.
This is done by associating an instance of the testbench preconditions class which is configured with 
the desired values and an operation to inject these values when invoked at test case initialization.

As the testbench constructs test cases, using provided operations of the stimulus and observation 
supertypes to add its specific stimuli and observation instances, the sequencer builds corresponding 
sequences in the Test Sequencer service context. 

The testbench test bucket, stimulus and observation subtype classes must provide instances which will 
respond to the invocations of injection and observation operations on the testbench supertype when 
triggered by the sequencing service as it works through the series of test cases. 
The testbench supertypes also provide operations to signal completion/failure to the test service.

The test cases are created in an instance based operation of a test bucket subtype. This operation 
will be invoked for each test bucket subtype as the sequencer runs through the set of buckets that 
constitute a test suite. The invoked operation creates subtype instances of stimulus and observation 
arranging them in order. Stimuli are added to a stimulus sequence of which there must be at least 
one created for a test case. If there are multiple sequences of stimuli they will run concurrently.
Observations are each appended to a specific stimulus and may be separated by chosen time delays.
Where the order in which observations should evaluate after a stimulus is unpredictable, they may be 
configured to evaluate concurrently; each one must succeed to consitute completion. If, however, 
during test case execution it is determined that a triggered operation is no longer required, there 
is a provision to "remove" it without causing failure of the test case.

An observation may be configured with optional timers: one limits the duration until lack of success 
will be timed a timeout failure; the other may determine a polling frequency for re-evaluation.
These timers may be independently configured with resolutions which may differ. The overall duration 
and the polling interval are specified as values using those configured resolution units.
Example: observations with timeouts specified in seconds may poll at some number of milliseconds.

Resolution values are propagated as defaults down the hierarchy from test suite to observation.
They can, however be overridden at any level - from where they now become defaults.

An observation may be configured to poll, repeatedly evaluating system conditions until it completes 
by reporting success, or fails after some time limit. Alternatively, invocation of an evaluation can
be triggered by some specific occurrence in the testbench - such as receipt of a status change in 
the system under test. This is achieved by associating a specific key with the observation; invoking 
a sequence "assess" signal, with a key value, will trigger evaluation of any current observations 
with a matching key. If desired, such an ''asynchronous'' observation may be associated with a separate 
stimulus sequence, allowing other sets of observations to proceed while it waits to be triggered.
A ''hybrid'' observation may wait for an initial trigger and subsequently poll in search of success.

Associated with each stimulus sequence there is one interval timer. A stimulus or observation can 
start (or restart) the timer on a sequence. A subsequent observation may read the elapsed time since 
the timer was started - and may optionally reset the timer value on reading. Interval timer 
resolution defaults to that of the sequence time resolution, but can be overridden.
',
	0,
	"00000000-0000-0000-0000-000000000000",
	0,
	'',
	'../../../Components/TestSequencer/TestSequencer.xtuml');
INSERT INTO PE_PE
	VALUES ("2727c7d1-a77f-417c-8f1b-bd16fc749175",
	1,
	"5480fefe-8866-48c2-8352-6ed990574e9e",
	"00000000-0000-0000-0000-000000000000",
	14);
INSERT INTO SQ_P
	VALUES ("56d9d283-f190-4472-b35e-cf4f8b326f47",
	"00000000-0000-0000-0000-000000000000");
INSERT INTO SQ_COP
	VALUES ("56d9d283-f190-4472-b35e-cf4f8b326f47",
	"00000000-0000-0000-0000-000000000000",
	'testbench',
	'testbench',
	'',
	0);
INSERT INTO PE_PE
	VALUES ("56d9d283-f190-4472-b35e-cf4f8b326f47",
	1,
	"5480fefe-8866-48c2-8352-6ed990574e9e",
	"00000000-0000-0000-0000-000000000000",
	14);
INSERT INTO PE_PE
	VALUES ("5480fefe-8866-48c2-8352-6ed990574e9e",
	1,
	"d9aa5180-6aaa-417c-a4da-6dc0f23b88ac",
	"00000000-0000-0000-0000-000000000000",
	7);
INSERT INTO EP_PKG_PROXY
	VALUES ("d9aa5180-6aaa-417c-a4da-6dc0f23b88ac",
	"00000000-0000-0000-0000-000000000000",
	"b06a8228-7533-46d6-b644-27cf49555288",
	'SequenceDiagrams',
	'',
	0,
	'../SequenceDiagrams.xtuml');
INSERT INTO S_SYS_PROXY
	VALUES ("b06a8228-7533-46d6-b644-27cf49555288",
	'TestFramework',
	1,
	'../../../TestFramework.xtuml');
